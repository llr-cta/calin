//-*-mode:protobuf; mode:font-lock;-*-

/*

   calin/proto/iact_data/telescope_event.proto -- Stephen Fegan -- 2015-12-19

   Protobufs for defining single-telescope event

   Copyright 2015, Stephen Fegan <sfegan@llr.in2p3.fr>
   LLR, Ecole polytechnique, CNRS/IN2P3, Universite Paris-Saclay

   This file is part of "calin"

   "calin" is free software: you can redistribute it and/or modify it
   under the terms of the GNU General Public License version 2 or
   later, as published by the Free Software Foundation.

   "calin" is distributed in the hope that it will be useful, but
   WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   General Public License for more details.

*/

syntax = "proto3";
option cc_enable_arenas = true;

import "calin.proto";
import "common_types.proto";

package calin.ix.iact_data.telescope_event;

message Clock {
  int32 clock_id                        = 1 [
    (CFO).desc = "Clock ID." ];
  common_types.Time time                = 2 [
    (CFO).desc = "Time according to the clock." ];
};

message ModuleClocks {
  int32 module_id                       = 1 [
    (CFO).desc = "Module ID within camera." ];
  repeated Clock clock                  = 2 [
    (CFO).desc = "Clock data." ];
};

message Counter {
  int32 counter_id                      = 1 [
    (CFO).desc = "Counter ID." ];
  int64 value                           = 2 [
    (CFO).desc = "Value of counter." ];
};

message ModuleCounters {
  int32 module_id                       = 1 [
    (CFO).desc = "Module ID within camera." ];
  repeated int32 counter_id             = 2 [
    (CFO).desc = "Ids of counters present." ];
  repeated int64 counter_value          = 3 [
    (CFO).desc = "Counter values." ];
};

message IntegratedCharges {
  bool all_channels_present             = 1 [
    (CFO).desc = "True if waveforms for all channels are present. In this case "
      "the channel_index and channel_id arrays are permitted to be empty." ];
  repeated int32 channel_index          = 2 [ packed=true,
    (CFO).desc = "Indexes within the image for all channels in the camera, or "
      "-1 if the the channel is not present." ];
  repeated int32 channel_id             = 3 [ packed=true,
    (CFO).desc = "IDs for channels with a charge present. If all channels in "
      "the camera are present then this can be empty." ];
  repeated uint32 charge                = 4 [ packed=true,
    (CFO).desc = "Integrated charges.",
    (CFO).units = "dc"];
  repeated uint32 peak_sample           = 5 [ packed=true,
    (CFO).desc = "Time of peak signal within readout window in samples.",
    (CFO).units = "samples"];
  repeated uint32 time_over_threshold   = 6 [ packed=true,
    (CFO).desc = "Time-over-threshold in samples.",
    (CFO).units = "samples"];
  repeated uint32 window_start          = 7 [ packed=true,
    (CFO).desc = "Start of integration or sampling window if different from "
      "one channel to another.",
    (CFO).units = "samples"];
  repeated uint32 window_size           = 8 [ packed=true,
    (CFO).desc = "Width of integration window if different from one channel "
      "to another.",
    (CFO).units = "samples"];
};

message ChannelWaveform {
  repeated uint32 samples               = 1 [ packed=true,
    (CFO).desc = "Waveform for one channel.",
    (CFO).units = "dc" ];
};

message Waveforms {
  bool all_channels_present             = 1 [
    (CFO).desc = "True if waveforms for all channels are present. In this case "
      "the channel_index and channel_id arrays are permitted to be empty." ];
  repeated int32 channel_index          = 2 [ packed=true,
    (CFO).desc = "Indexes within the image for all channels in the camera, or "
      "-1 if the the channel is not present." ];
  repeated int32 channel_id             = 3 [ packed=true,
    (CFO).desc = "IDs for channels with a charge present. If all channels in "
      "the camera are present then this can be empty." ];
  repeated ChannelWaveform waveform     = 5 [
    (CFO).desc = "Sampled waveforms.",
    (CFO).units = "dc" ];
  uint32 num_samples_per_channel        = 6 [
    (CFO).desc = "Number of samples per channel if this is constant per event, "
      "zero otherwise.",
    (CFO).units = "samples" ];
};

message DigitizedSkyImage {
  IntegratedCharges camera_charges      = 1 [
    (CFO).desc = "Integrated charge (waveform sum) in each of the pixels "
      "retained in the event." ];
  Waveforms camera_waveforms            = 2 [
    (CFO).desc = "Regularly sampled waveform from each of the pixels "
      "retained in the event." ];
};

message ChannelTriggerMap {
  repeated uint32 hit_channel_id        = 1 [ packed=true,
      (CFO).desc = "Channel ID for all channels that triggered." ];
};

enum TriggerType {
  TRIGGER_SCIENCE              = 0;
  TRIGGER_SOFTWARE             = 1;
  TRIGGER_PEDESTAL             = 2;
  TRIGGER_EXTENAL_FLASHER      = 3;
  TRIGGER_INTERNAL_FLASHER     = 4;
  TRIGGER_FORCED_BY_ARRAY      = 5;
};

enum ImageTreatmentMode {
  TREATMENT_SCIENCE            = 0;
  TREATMENT_PASS_THROUGH       = 1;
};

message TelescopeEvent {
  uint64 source_event_index             = 1 [
    (CFO).desc = "Index of the event relative to the source." ];
  int32 telescope_id                    = 2 [
    (CFO).desc = "Telescope ID." ];
  int64 local_event_number              = 3 [
    (CFO).desc = "Local (camera) event number." ];
  TriggerType trigger_type              = 4 [
    (CFO).desc = "Trigger type." ];
  bool array_trigger_received           = 5 [
    (CFO).desc = "Flag for whether array trigger was received." ];
  int64 array_event_number              = 6 [
    (CFO).desc = "Array event number or \"-1\" if not received." ];

  bool all_modules_present              = 10 [
    (CFO).desc = "True if all modules are present in the image." ];
  repeated int32 module_index           = 11 [
    (CFO).desc = "Index of each expected module in event, or -1 if module "
      "is not present in this event." ];
  repeated int32 module_id              = 12 [
    (CFO).desc = "Module id of each module present in the event ordered by "
      "its index in the data. For each module present in the event we are "
      "guarenteed that module_id[module_index[id]]=id."];

  repeated Clock camera_clock           = 20 [
    (CFO).desc = "Vector of camera clock times associated with event." ];
  repeated ModuleClocks module_clock    = 21 [
    (CFO).desc = "Vector of camera clock times associated with event." ];
  repeated Counter camera_counter       = 30 [
    (CFO).desc = "Vector of camera counter values associated with event." ];
  repeated ModuleCounters module_counter = 31 [
    (CFO).desc = "Vector of module counter values associated with event." ];

  ImageTreatmentMode image_treatment    = 99 [
    (CFO).desc = "Image treatment mode." ];
  DigitizedSkyImage image               = 100 [
    (CFO).desc = "Sky image recorded in a single-gain camera." ];
  DigitizedSkyImage high_gain_image     = 101 [
    (CFO).desc = "Sky image recorded in the high-gain path of a dual-gain "
      "camera." ];
  DigitizedSkyImage low_gain_image      = 102 [
    (CFO).desc = "Sky image recorded in the low-gain path of a dual-gain "
      "camera." ];

  ChannelTriggerMap trigger_map         = 200 [
      (CFO).desc = "List of channels that triggered." ];
};
